<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[小南瓜的备忘录]]></title>
    <url>%2F2019%2F10%2F11%2F%E5%B0%8F%E5%8D%97%E7%93%9C%E7%9A%84%E5%A4%87%E5%BF%98%E5%BD%95%2F</url>
    <content type="text"><![CDATA[这篇blog主要用于记录各种场景下用到的一些容易遗忘的基本操作，以免去每次搜索的麻烦 Ubuntu系统安装刻录引导盘UltraISO里面刻录的时候类型要选raw，不然会有问题 开机进入grub首先ls看系统里面的硬盘分区，然后依次输入 1ls （hd0,gptx)/ 看有没有boot文件夹找到boot文件夹之后 1234set root=hd0,gptx //x为有boot文件夹的编号set prefix=(hd0,gptx)/boot/grubinsmod normalnormal 此时应该会进入登录界面登录后联网，终端输入 12sudo add-apt-repository ppa:yannubuntu/boot-repair &amp;&amp; sudo apt-get updatesudo apt-get install -y boot-repair &amp;&amp; boot-repair 选recommended repair，然后按提示进行操作就好了 vim剪切板1sudo apt install vim-gtk 搜狗输入法下载之后dpkg安装，然后 1sudo apt-get install -f 安装需要的东西，设置里面input method system选fcitx，重启重启之后打开fcitx的设置，加入搜狗输入法。 hexo换电脑（ubuntu下）git把源码clone过来 123npm install -g hexonpm installnpm install hexo-deployer-git 就完事了]]></content>
      <tags>
        <tag>备忘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[百度之星初赛第四场 1002]]></title>
    <url>%2F2019%2F08%2F28%2F%E7%99%BE%E5%BA%A6%E4%B9%8B%E6%98%9F%E5%88%9D%E8%B5%9B%E7%AC%AC%E5%9B%9B%E5%9C%BA-1002%2F</url>
    <content type="text"><![CDATA[前三场都忘记了，打了百度之星预赛的第四场。上来1001不会搞int128然后罚时爆炸，整1002被BPM带进坑调了两个小时发现这个想法有问题x。不过BPM的方法提醒了我一点，结果在还剩半小时的时候重新想，还剩15分钟的时候重新写，最后极限过掉啦！好歹是进了复赛qwq。另外吐槽那个明明是难题结果数据水了导致200人过了的1006。差点我就没了x好啦言归正传，我们来说一下这道题。 题意在一个边长为1的正方形上有四个点，你可以把这四个点沿着正方形的边框顺时针或者逆时针移动，使得最后这四个点构成一个矩形。问移动距离之和最小是多少。四个点必须分别在正方形的四条边上，顶点可以算这两条边中的任意一个。矩形可以退化成直线，联系前面的条件，即可以退化成正方形的对角线。 题解首先我们可以很容易的看出肯定有一个点是不动的，因为假设最后最优的矩形四个点都不在起始位置，我们肯定可以移动一条边，让这条边上一个点回到它的起始位置，同时到另一个点的距离增加不超过这次移动对这个点造成的距离减少。这样我们可以首先枚举这个固定点。由三角形全等可以很容易得到对角点的位置。那么其他两个点肯定在这个线段为直径的圆上。所以最后构成的矩形只有两种可能的情况。一种是45度角的矩形另一种是正方形所以对每个点其实只有两种情况枚举一下其他每个点到哪一个目标点，然后取最小距离就好啦 为了方便计算，我先将每个点转化成从零点开始逆时针移动到这个点的距离，并且记录了每个点逆时针的下一个正方形顶点 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798/************************************************************************* &gt; File Name: B.cpp &gt; Author: PumpkinYing &gt; Created Time: 2019/8/25 14:56:52 ************************************************************************/#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;string.h&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;cmath&gt;#include &lt;iomanip&gt;using namespace std;#define mem(a,b) memset(a,b,sizeof(a))typedef long long ll;double dis[10]; #点到原点逆时针距离int pos[10]; #点逆时针下一个正方形顶点#将编号为id的点移动到距离原点逆时针距离为d的点需要的移动距离double mv(int id,double d) &#123; while(d &gt; 4) d -= 4; if(dis[id] &gt; d) return min(dis[id]-d,d+4-dis[id]); else return min(d-dis[id],dis[id]+4-d);&#125;int main() &#123; int T; cin &gt;&gt; T; while(T--) &#123; int n; for(int i = 0;i &lt; 4;i++) &#123; double x,y; cin &gt;&gt; x &gt;&gt; y; if(y == 0) &#123; pos[i] = 1; dis[i] = x; &#125; else if(x == 1) &#123; pos[i] = 2; dis[i] = 1+y; &#125; else if(y == 1) &#123; pos[i] = 3; dis[i] = 2+1-x; &#125; else &#123; pos[i] = 4; dis[i] = 3+1-y; &#125; &#125; double ans = 5100; #正方形 for(int i = 0;i &lt; 4;i++) &#123; for(int j = 0;j &lt; 4;j++) &#123; double tmp = 0; if(i == j) continue; for(int l = 0;l &lt; 4;l++) &#123; if(l == i || l == j) continue; for(int r = 0;r &lt; 4;r++) &#123; if(r == i || r == j || r == l) continue; tmp = mv(j,dis[i]+2.0)+mv(l,dis[i]+1.0)+mv(r,dis[i]+3.0); ans = min(ans,tmp); &#125; &#125; &#125; &#125; #45度矩形 for(int i = 0;i &lt; 4;i++) &#123; for(int j = 0;j &lt; 4;j++) &#123; double op = pos[i]-dis[i]; #到下一个正方形顶点的距离 double tmp = 0; if(i == j) continue; for(int l = 0;l &lt; 4;l++) &#123; if(l == i || l == j) continue; for(int r = 0;r &lt; 4;r++) &#123; if(r == i || r == j || r == l) continue; tmp = mv(j,dis[i]+2*op)+mv(l,dis[i]+2)+mv(r,dis[i]+2+2*op); ans = min(ans,tmp); &#125; &#125; &#125; &#125; printf("%.12f\n",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCPC网络赛 1004]]></title>
    <url>%2F2019%2F08%2F28%2FCCPC%E7%BD%91%E7%BB%9C%E8%B5%9B-1004%2F</url>
    <content type="text"><![CDATA[老年退役选手去打了一下下网络赛，哑巴里很菜呀XD。BPM在敲1003的时候我和洛洛想1004，但是完全想不到，结果BPM写完之后一听题意就秒掉了呢qwq可惜这家伙差几秒钟没能把AC的代码交上去。感觉触及到了我的思路盲区，所以记录一下。 题意给一个有向图，重边自环都可能有，每次询问问这个图里面权值和第$k$小的路径权值和是多少。点，边，询问数量$5e4$，$k$最大$5e4$。 题解k的范围很容易想到递推，即现在已知第k小的路径，求第k+1小的路径。考虑从只有一条边的路径开始，每次添加一条边，将路径往下扩展。将从一个点出发的边按权值从小到大排序，那么对于这个点结束的路径，添加小的边会得到更小的路径。我们记录最后一条边是倒数第二个点出发的第几大边。将当前的所有路径丢进一个优先队列，每次取出最小路径的时候，加两条新的路径进去。如图：在将最后一条边为第k大的路径取出来的时候，我们加进去两条新的路径，一条是去掉k加上k+1，另外是在k后面加上末尾点出发的最小边，即第0大的边。每次队列中拿出一个放入两个，最多有2m个路径在里面。真是巧妙呢XD。]]></content>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[闵可夫斯基和]]></title>
    <url>%2F2019%2F08%2F16%2F%E9%97%B5%E5%8F%AF%E5%A4%AB%E6%96%AF%E5%9F%BA%E5%92%8C%2F</url>
    <content type="text"><![CDATA[之前在省赛和cf教育场都碰到了闵可夫斯基和这个东西，于是在维基百科学习了一波之后来写一下。 定义在几何中，两个点集$S_1,S_2$的闵可夫斯基和被定义为$$ S_1+S_2 = \{ a+b | a \in S_1,b \in S_2 \} $$ 闵可夫斯基和的凸包首先第一个性质，对于两个点集$S_1,S_2$，它们的闵可夫斯基和的凸包等于它们凸包的闵可夫斯基和，即$$ Conv(S_1+S_2) = Conv(S_1)+Conv(S_2) $$同样扩展到多个点集也是这样的$$ Conv( \sum S_n) = \sum Conv(S_n)) $$那么为什么呢 对于两个凸包相加，我们可以看成一个凸包沿着另一个凸包转一圈之后形成的图形 .Small{ width:500px; height:500px; margin:0 auto; } .Small img{ width:"100%"; height: auto; } 比如我现在有个凸包A 然后我把凸包B放上去转一圈 把外面的点连起来就得到了两个凸包的闵可夫斯基和的凸包 那么这个得到的图形明显是个凸包（x对不起我不会证明 而之前在原凸包里面的点在取和之后也肯定在这个大凸包里面 所以就有了上面的结论 怎么求两个凸包的闵可夫斯基和先上结论：把两个凸包的所有的边极角排序，然后依次相连就好了 是不是非常的鹅妹子嘤XD 这里试图给个证明： 最后得到的凸包，它的边分两种，一种是B凸包上的某个点沿着A凸包的某一条边平移得到的，另一种是B凸包的边直接作为外面凸包的边。 第一种边很明显A中的每条边都会出现一次，因为每条边被沿着走了一次 而第二种，B中的边在B转到A中一个点，并且A的前一条边极角比它小，后一条边极角比它大的时候，会成为一次大凸包上的边 因此A，B中所有的边都出现了一次 而凸包的边又是按极角排的 所以把A，B里面所有的边极角排序之后首尾相连就可以啦XD]]></content>
      <tags>
        <tag>ACM算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1025 F题]]></title>
    <url>%2F2019%2F07%2F31%2FCF1025-F%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目链接：http://codeforces.com/contest/1025/problem/F 题意有2000个点，任意三点不共线，问有多少对互不相交的三角形 题解刚开始想的是枚举分割线，然后三点都在线同一边的个数。一开始想的是这条分割线作为其中一条三角形的一边，但是这样会有情况不好处理 比如： 这样在枚举到如图两条边的时候，这种情况分别会被算一次 而只会在枚举如图的边的时候被算一次 这样就出现问题啦 正确的枚举方法是让分割线分别经过两个三角形的一个顶点 就想象一条线放在两个三角形中间，然后努力向左转和努力向右转这样每一对三角形都会有两条分割线 所以枚举分割线上的两个点然后再在分割线两边分别选两个点与它们相连就好啦 分割线两边的点数可以通过固定分割线的一个顶点，将其他顶点极角排序，然后O(n)扫过去来维护 最后因为每对三角形一定被算了两次，所以总答案除以2就好 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293/********************************************************************* &gt; File Name: F.cpp &gt; Author: PumpkinYing &gt; Created Time: 2018/8/20 22:47:12 ********************************************************************/#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;string.h&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;cmath&gt;using namespace std;#define mem(a,b) memset(a,b,sizeof(a))#define PII pair&lt;int,int&gt;#define PLL pair&lt;long long,long long&gt;typedef long long ll;const int maxn = 2010;const ll INF = 1e9+10;struct Point&#123; int x,y;&#125;ps[maxn],cps[maxn];PLL getK(Point a,Point b)&#123; if(a.x == b.x) return PLL(INF,1); return PLL(a.y-b.y,a.x-b.x);&#125;bool cmp(Point a,Point b)&#123; PLL k1 = getK(ps[0],a); PLL k2 = getK(ps[0],b); int p1 = k1.first*k2.second-k1.second*k2.first &lt; 0 ? -1 : 1; int p2 = k1.second*k2.second &lt; 0 ? -1 : 1; return p1*p2 &lt; 0;&#125;int main()&#123; int n; scanf("%d",&amp;n); for(int i = 0;i &lt; n;i++) scanf("%d%d",&amp;cps[i].x,&amp;cps[i].y); ll ans = 0; for(int p = 0;p &lt; n;p++) &#123; for(int i = 0;i &lt; n;i++) ps[i] = cps[i]; swap(ps[0],ps[p]); sort(ps+1,ps+n,cmp); ll cntl = 0; ll cntr = 0; for(int i = 1;i &lt; n;i++) &#123; if(ps[i].x &lt; ps[0].x || (ps[i].x == ps[0].x &amp;&amp; ps[i].y &lt; ps[0].y)) cntl++; else cntr++; &#125; for(int i = 1;i &lt; n;i++) &#123; if(ps[i].x &lt; ps[0].x || (ps[i].x == ps[0].x &amp;&amp; ps[i].y &lt; ps[0].y)) &#123; cntl--; ans += cntl*(cntl-1)/2*cntr*(cntr-1)/2; cntr++; &#125; else &#123; cntr--; ans += cntl*(cntl-1)/2*cntr*(cntr-1)/2; cntl++; &#125; &#125; &#125; printf("%I64d\n",ans/2); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5484]]></title>
    <url>%2F2019%2F07%2F31%2FHDU-5484%2F</url>
    <content type="text"><![CDATA[题意有1e5个点，要用一些照相机（500个）拍到所有的点。一个点能被拍到有三种情况：在某个照相机的位置，在某两个照相机的连线上，或者在三个照相机形成的三角形里面。求最少用多少相机拍到所有的点。 题解给要拍的点求个凸包，然后把500个相机两两之间在凸包外的边处理出来，然后用dijkstra求最短环就好了。主要是处理凸包外的边的方法非常的鹅妹子嘤。把凸包上的边按极角（和x正方向的夹角）排序，然后二分找到第一个极角比查询边大的边，只要这条边在查询边的左边就好了。感觉一下就是对的（逃 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212/************************************************************************* &gt; File Name: HDU5484.cpp &gt; Author: PumpkinYing &gt; Created Time: 2018/12/3 15:05:14 ************************************************************************/#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;string.h&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;bitset&gt;#include &lt;stack&gt;#include &lt;cmath&gt;using namespace std;#define mem(a,b) memset(a,b,sizeof(a))#define prii pair&lt;int,int&gt;#define prdd pair&lt;double,double&gt;#define rep(i,l,r) for(int i = l;i &lt; r;i++)#define rep_(i,l,r) for(int i = l;i &lt;= r;i++)typedef long long ll;const double PI = acos(-1.0);const int maxn = 100010;const int maxm = 510;struct Point &#123; ll x,y; void read() &#123; scanf("%lld%lld",&amp;x,&amp;y); &#125; Point(ll x = 0,ll y = 0) : x(x),y(y) &#123;&#125;&#125;ps[maxn],ms[maxm];typedef Point Vector;Vector operator - (Point a,Point b) &#123; return Vector(a.x-b.x,a.y-b.y);&#125;bool operator == (Point a,Point b) &#123; return a.x == b.x &amp;&amp; a.y == b.y;&#125;ll cross(Vector a,Vector b) &#123; return a.x*b.y-a.y*b.x;&#125;ll dot(Vector a,Vector b) &#123; return a.x*b.x+a.y*b.y;&#125;ll dis2(Point a,Point b) &#123; return dot(a-b,a-b);&#125;Point base;bool operator &lt; (Point a,Point b) &#123; if(cross(a-base,b-base) == 0) return dis2(a,base) &lt; dis2(b,base); return cross(a-base,b-base) &gt; 0;&#125;struct Seg&#123; Point a,b; double ang; Seg(Point a = Point(0,0),Point b = Point(0,0)) : a(a),b(b) &#123; Vector vec = b-a; ang = atan2(vec.y,vec.x); &#125; bool operator &lt; (const Seg&amp; s) const &#123; return ang &lt; s.ang; &#125;&#125;ls[maxn];bool onSeg(Point a,Seg s) &#123; return cross(a-s.a,a-s.b) == 0 &amp;&amp; dot(a-s.a,a-s.b) &lt;= 0;&#125;Point st[maxn];int convexHull(Point* ps,int n) &#123; int top = 0; if(n &lt; 3) &#123; rep(i,0,n) st[top++] = ps[i]; return top; &#125; rep(i,0,n) &#123; if(ps[i].y &lt; ps[0].y) swap(ps[i],ps[0]); else if(ps[i].y == ps[0].y &amp;&amp; ps[i].x &lt; ps[0].x) swap(ps[i],ps[0]); &#125; sort(ps+1,ps+n); st[top++] = ps[0]; st[top++] = ps[1]; rep(i,2,n) &#123; while(top &gt;= 2 &amp;&amp; cross(st[top-1]-st[top-2],ps[i]-st[top-1]) &lt;= 0) top--; st[top++] = ps[i]; &#125; return top;&#125;int w[maxm][maxm];void makeMap(Seg* ls,int tot,Point* ms,int m) &#123; mem(w,0); rep(i,0,m) rep(j,0,m) &#123; if(i == j) continue; Seg tmp = Seg(ms[i],ms[j]); int p = lower_bound(ls,ls+tot,tmp)-ls; p %= tot; if(cross(tmp.b-tmp.a,ls[p].a-tmp.a) &gt;= 0 &amp;&amp; cross(tmp.b-tmp.a,ls[p].b-tmp.a) &gt;= 0) w[i][j] = 1; &#125;&#125;int d[maxm];int dij(int x,int m) &#123; mem(d,0x3f); d[x] = 0; priority_queue&lt;prii,vector&lt;prii&gt;,greater&lt;prii&gt; &gt; q; q.push(prii(0,x)); while(!q.empty()) &#123; prii tmp = q.top(); q.pop(); int t = tmp.second; if(tmp.first != d[t]) continue; if(w[t][x]) return d[t]+1; rep(i,0,m) &#123; if(w[t][i] == 1) &#123; if(d[t]+1 &lt; d[i]) &#123; d[i] = d[t]+1; q.push(prii(d[i],i)); &#125; &#125; &#125; &#125; return -1;&#125;int main() &#123; int T; scanf("%d",&amp;T); int kase = 1; while(T--) &#123; int n,m; scanf("%d%d",&amp;n,&amp;m); rep(i,0,n) ps[i].read(); rep(i,0,m) ms[i].read(); int tot = convexHull(ps,n); int ans = -1; if(tot == 1) &#123; rep(i,0,m) &#123; if(ms[i] == st[0]) &#123; ans = 1; break; &#125; &#125; if(ans == 1) &#123; printf("Case #%d: 1\n",kase++); continue; &#125; rep(i,0,m) rep(j,i+1,m) &#123; if(onSeg(st[0],Seg(ms[i],ms[j]))) &#123; ans = 2; break; &#125; &#125; if(ans == 2) &#123; printf("Case #%d: 2\n",kase++); continue; &#125; &#125; else if(tot == 2) &#123; rep(i,0,m) rep(j,i+1,m) &#123; Seg s = Seg(ms[i],ms[j]); if(onSeg(st[0],s) &amp;&amp; onSeg(st[1],s)) &#123; ans = 2; break; &#125; &#125; if(ans == 2) &#123; printf("Case #%d: 2\n",kase++); continue; &#125; &#125; rep(i,0,tot) ls[i] = Seg(st[i],st[(i+1)%tot]); sort(ls,ls+tot); makeMap(ls,tot,ms,m); /* rep(i,0,m) &#123; rep(j,0,m) cerr&lt;&lt;w[i][j]&lt;&lt;' '; cerr&lt;&lt;endl; &#125; */ rep(i,0,m) &#123; int tmp = dij(i,m); if(ans == -1) ans = tmp; else if(tmp != -1) ans = min(ans,tmp); &#125; printf("Case #%d: %d\n",kase++,ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
</search>
